from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List
from .crud import CRUD
from .models import *
from .db import init_db, get_session

router = APIRouter()

# Initialize DB at import
init_db()

# ------ Generic CRUD Routes ------
{% for m in models %}
{{ m.name.lower() }}_crud = CRUD({{ m.name }})

@router.get("/{{ m.table }}", response_model=List[{{ m.name }}])
def list_{{ m.table }}(skip: int = 0, limit: int = 50):
    return {{ m.name.lower() }}_crud.list(skip=skip, limit=limit)

@router.get("/{{ m.table }}/{id}", response_model={{ m.name }})
def get_{{ m.table }}(id: int):
    obj = {{ m.name.lower() }}_crud.get(id)
    if not obj: raise HTTPException(status_code=404, detail="{{ m.name }} not found")
    return obj

@router.post("/{{ m.table }}", response_model={{ m.name }})
def create_{{ m.table }}(payload: {{ m.name }}):
    return {{ m.name.lower() }}_crud.create(payload)

class {{ m.name }}Update(BaseModel):
    {% for f in m.fields if not f.pk %}
    {{ f.name }}: {{ f.type_hint }} | None = None
    {% endfor %}

@router.patch("/{{ m.table }}/{id}", response_model={{ m.name }})
def update_{{ m.table }}(id: int, payload: {{ m.name }}Update):
    obj = {{ m.name.lower() }}_crud.update(id, payload.model_dump(exclude_unset=True))
    if not obj: raise HTTPException(status_code=404, detail="{{ m.name }} not found")
    return obj

@router.delete("/{{ m.table }}/{id}")
def delete_{{ m.table }}(id: int):
    ok = {{ m.name.lower() }}_crud.delete(id)
    if not ok: raise HTTPException(status_code=404, detail="{{ m.name }} not found")
    return {"ok": True}
{% endfor %}

# ------ Domain Extras ------
{% if domain == "healthcare" %}
class SchedulePayload(BaseModel):
    patient_id: int
    doctor_id: int
    scheduled_for: datetime
    notes: str | None = None

@router.post("/appointments/schedule", response_model=Appointment)
def schedule_appointment(payload: SchedulePayload):
    with get_session() as s:
        pat = s.get(Patient, payload.patient_id)
        doc = s.get(Doctor, payload.doctor_id)
        if not pat or not doc:
            raise HTTPException(status_code=400, detail="Invalid patient or doctor")
        ap = Appointment(patient_id=payload.patient_id, doctor_id=payload.doctor_id,
                         scheduled_for=payload.scheduled_for, notes=payload.notes or "")
        s.add(ap); s.commit(); s.refresh(ap)
        return ap

{% elif domain == "real_estate" %}
class AssignLeadPayload(BaseModel):
    lead_id: int
    agent_id: int

@router.post("/leads/assign")
def assign_lead(payload: AssignLeadPayload):
    with get_session() as s:
        lead = s.get(Lead, payload.lead_id)
        agent = s.get(Agent, payload.agent_id)
        if not lead or not agent:
            raise HTTPException(status_code=400, detail="Invalid lead or agent")
        lead.assigned_agent_id = payload.agent_id
        s.add(lead); s.commit()
        return {"ok": True, "lead_id": lead.id, "assigned_agent_id": agent.id}

{% elif domain == "ecommerce" %}
@router.post("/orders/{order_id}/compute-total", response_model=Order)
def compute_order_total(order_id: int):
    with get_session() as s:
        order = s.get(Order, order_id)
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        product = s.get(Product, order.product_id)
        if not product:
            raise HTTPException(status_code=400, detail="Invalid product")
        order.total = (order.quantity or 0) * (product.price or 0.0)
        s.add(order); s.commit(); s.refresh(order)
        return order

{% elif domain == "education" %}
class EnrollPayload(BaseModel):
    student_id: int
    course_id: int

@router.post("/admissions/enroll", response_model=Admission)
def enroll_student(payload: EnrollPayload):
    with get_session() as s:
        st = s.get(Student, payload.student_id)
        cr = s.get(Course, payload.course_id)
        if not st or not cr:
            raise HTTPException(status_code=400, detail="Invalid student or course")
        adm = Admission(student_id=payload.student_id, course_id=payload.course_id, status="enrolled")
        s.add(adm); s.commit(); s.refresh(adm)
        return adm

{% elif domain == "freelancers" %}
class GenerateInvoicePayload(BaseModel):
    project_id: int

@router.post("/invoices/generate", response_model=Invoice)
def generate_invoice(payload: GenerateInvoicePayload):
    with get_session() as s:
        project = s.get(Project, payload.project_id)
        if not project:
            raise HTTPException(status_code=404, detail="Project not found")
        rate = project.rate_per_hour or 0.0
        hours = 0.0
        from sqlmodel import select
        for te in s.exec(select(TimeEntry).where(TimeEntry.project_id == project.id)):
            hours += te.hours or 0.0
        amount = hours * rate
        inv = Invoice(project_id=project.id, amount=amount, status="draft")
        s.add(inv); s.commit(); s.refresh(inv)
        return inv
{% endif %}
